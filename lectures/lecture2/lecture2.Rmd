---
title: "Lecture 2: Investigating data patterns" # potentially push to header
subtitle:  "EDUC 263: Managing and Manipulating Data Using R"
author: Ozan Jaquette
date: 
classoption: dvipsnames  # for colors
fontsize: 8pt
urlcolor: blue
output:
  beamer_presentation:
    keep_tex: true
    toc: true
    slide_level: 3
    theme: default # AnnArbor # push to header?
    #colortheme: "dolphin" # push to header?
    #fonttheme: "structurebold"
    highlight: tango # Supported styles include "default", "tango", "pygments", "kate", "monochrome", "espresso", "zenburn", and "haddock" (specify null to prevent syntax highlighting); push to header
    df_print: tibble #default # tibble # push to header?    
    latex_engine: xelatex #  Available engines are pdflatex [default], xelatex, and lualatex; The main reasons you may want to use xelatex or lualatex are: (1) They support Unicode better; (2) It is easier to make use of system fonts.
    includes:
      in_header: ../beamer_header.tex
      #after_body: table-of-contents.txt 
---

<!-- CAN THIS BE MOVED TO SOME KIND OF HEADER FILE? --> 

```{r, echo=FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>", highlight = TRUE)
#knitr::opts_chunk$set(collapse = TRUE, comment = "#>", highlight = TRUE)
  #comment = "#>" makes it so results from a code chunk start with "#>"; default is "##"
```

### Libraries we will use today

```{r}
library(tidyverse)
```


# Directories and filepaths [?lec1 or lec2?]


### Working directory

__(Current) Working directory__

- the folder/directory in which you are currently working
- this is where R looks for files
- Files located in your current working directory can be accessed without specifying a filepath because R automatically looks in this folder

Function \hlgc{getwd()} shows current working directory
```{r}
getwd()
```
Command \hlgc{list.files()} lists all files located in working directory
```{r}
getwd()
list.files()
```

### Working directory, "Code chunks" vs. "console" and "R scripts"

When you run __code chunks__ in RMarkdown files (.Rmd), the working directory is set to the filepath where the .Rmd file is stored

```{r}
getwd()
list.files()
```

When you run code from the __R Console__ or an __R Script__, the working directory is....

\medskip I find this very annoying

Command \hlgc{getwd()} shows current working directory
```{r}
getwd()
```

### Absolute vs. relative filepath


# Investigating objects

### Data on off-campus recruiting events by public universities

```{r}
rm(list = ls()) # remove all objects
getwd()

#load dataset with one obs per recruiting event
load("../../data/recruiting/recruit_event_somevars.Rdata")

#load dataset with one obs per high school
load("../../data/recruiting/recruit_school_somevars.Rdata")
```
Object \hlgc{df\_event\}

- One observation per university, recruiting event

Object \hlgc{df\_event\}

- One observation per high school (visited and non-visited)

### Listing objects

\hlgc{ls()} function lists objects currently open in R

- This is different from files in current working directory 
```{r}
x <- "hello!"
ls() # Objects open in R
list.files() # files in working directory
```
\hlgc{rm()} function removes specified objects open in R
```{r}
rm(x)
ls()
```
Command to remove all objects open in R (I don't run it)
```{r, eval=FALSE}
rm(list = ls())
```

### Describing objects, focus on __data frames__

Object __type__ and __length__
```{r}
typeof(df_event)
length(df_event) # = num elements = num columns
```
Number of __rows__ and __columns__
```{r}
nrow(df_event) # num rows = num observations
ncol(df_event) # num columns = num variables
dim(df_event) # shows number rows by columns
```

# Variables names

### Introduction to the \hlgc{dplyr} library

\hlgc{dplyr}, a package within the \hlgc{tidyverse} suite of packages, provide tools for manipulating data frames

- Wickham describes functions within \hlgc{dplyr} as a set of "verbs" that fall in the broader categories of __subsetting__, __sorting__, and __transforming__

Today | Next two weeks
------------- | -------------
__Subsetting data__ | __Transforming data__
- \hlgc{select()} variables  | - \hlgc{mutate()} creates new variables
- \hlgc{filter()} observations | - \hlgc{summarize()} calculates across rows
__Sorting data__ | - \hlgc{group\_by()} to calculate across rows within groups
- \hlgc{arrange()} | 

All \hlgc{dplyr} verbs (i.e., functions) work as follows

1. first argument is a data frame"
1. subsequent arguments describe what to do with variables and observations in data frame
    - refer to variable names without quotes
1. result of the function is a new data frame

### Variable names

\hlgc{names()} function lists names of elements in an object

- when object is a data frame, each element name is a variable name

```{r results="hide"}
#Output omitted
names(df_event)
```
Refer to named elements in object using `obj_name$element_name`

- when object is a dataframe: `obj_name$varname`

```{r}
typeof(df_event$instnm)
typeof(df_event$avgmedian_inc_2564)
```
This approach to isolating variables is very useful for investigating and manipulating data

### Rename variables

\hlgc{rename()} function renames variables within a data frame object

\medskip Syntax:

- \hlgc{rename(obj\_name, new\_name = old\_name,\ldots)}
\medskip
```{r results="hide"}
rename(df_event, g12_offered = g12offered, titlei = titlei_status_pub)
names(df_event)
```
Variable names do not change permanently unless we combine rename with assignment
\medskip
```{r results="hide"}
rename_event <- rename(df_event, g12_offered = g12offered, titlei = titlei_status_pub)
names(rename_event)
rm(rename_event)
```

# Selecting variables and printing data

### Select variables using \hlgc{select()} function

Printing observations is key to investigating data, but datasets often have hundreds, thousands of variables

\hlgc{select()} function selects __columns__ of data (i.e., variables) you specify

- See syntax in help file

Select __without assignment__ simply prints data for selected variables

```{r}
select(df_event,instnm,event_date,event_type,event_state,med_inc)
```
### Select variables using \hlgc{select()} function

Select __with assignment__ creates a new object containing only the variables you specify

```{r}
event_small <- select(df_event,instnm,event_date,event_type,event_state,med_inc)
event_small
```

### Select

We can also use "helper functions" \hlgc{starts\_with()}, \hlgc{contains()}, and \hlgc{ends\_with()} to choose columns 

```{r}
names(df_event)
select(df_event,instnm,starts_with("event"))
```

### Exercise

The data frame "df_school" has one observation for each high school and indicators for whether the high school received a recruiting visit.

```{r results="hide"}
names(df_school)
```


1. Use \hlgc{select()} to familiarize yourself with the data frame
1. Practice using the \hlgc{contains()} and \hlgc{ends\_with()} helper functions to to choose variables

### Viewing and printing data

- Use the \hlgc{View()} function to view data in a browser
```{r eval=FALSE}
View(df_event)
```
- \hlgc{head()} to show the first _n_ rows
```{r results="hide"}
head(df_event, n=5)
```
### Viewing and printing data

Use `{obj_name[<rows>,<cols>]` to print specific rows and columns of a data frame

- particularly powerful when combined with sequences (e.g., \hlgc{1:10})

\medskip Examples:

- Print first five rows
```{r results="hide"}
df_event[1:5, ]
```
- Print first five rows and first three columns
```{r results="hide"}
df_event[1:5, 1:3]
```
- Print first three columns of the 100th observation
```{r results="hide"}
df_event[100, 1:3]
```
Print the 50th observation, all variables
```{r results="hide"}
df_event[50,]
```
### Viewing and printing data

- type \hlgc{obj\_name\textdollar var\_name} to print obs for a variable
```{r results="hide"}
df_event$event_state

```
- can be combined with sequences
```{r}
df_event$event_state[1:10]
df_event$event_type[6:10]
```
- can also print multiple variables using \hlgc{combine()} function
```{r}
c(df_event$event_state[1:5],df_event$event_type[1:5])
```


### Exercise

Create a printing exercise using the df_school

1. Use head() to print first 5 observations
1. Use select to print observations of variables of your choosing
1. Use \hlgc{obj\_name\textdollar var\_name[1:10]} to print the first 10 observations of a variable
1. use combine()

# Filtering data

### Filter
filter() allows you to select observations based on values of variables

- Arguments
    - first argument is name of data frame
    - subsequent arguments are _expressions_ to filter the data frame
- What is the result of a \hlgc{filter()} command?
    - \hlgc{filter()} returns the rows where the condition is \hlgc{TRUE}

\medskip Example using data frame object \hlgc{df\_school}, where each observation is a high school

- Show all obs where the high school received 1 visit from UC Berkeley (110635) [output omitted]
```{r results="hide"}
filter(df_school,visits_by_110635 == 1)
```
- Must __assign__ to create new object based on filter
```{r results="hide"}
berk_boulder <- filter(df_school,visits_by_110635 == 1, visits_by_126614==1)
berk_boulder
```
### Filter, character variables

- Use quotes \hlgc{''} or \hlgc{""} to refer to character variables

```{r results="hide"}
#Berkeley
filter(df_school,visits_by_110635 == 1, school_type == "private", state_code == "CA")
#Bama
filter(df_school,visits_by_100751 == 1, school_type == "private", state_code == "CA") 

#Berkeley and Bama
filter(df_school,visits_by_100751 == 1, visits_by_110635 == 1, school_type == "private", state_code == "CA") 
```


### Logical operators for comparisons

Symbol | Meaning
-------|-------
`==` | Equal to
`!=` | Not equal to
`>` | greater than
`>=` | greater than or equal to
`<` | less than
`<=` | less than or equal to
`&` | AND 
`|` | OR
`%in` | includes

Table: Logical operators

\medskip 

!["Boolean" operations, x=left circle, y=right circle, from Wichkam (2018)](transform-logical.png){width=50% }

### Filters and comparisons

Schools visited by Bama (100751) and/or Berkeley (110635)

```{r results="hide"}
#berkeley and bama
filter(df_school,visits_by_100751 >= 1, visits_by_110635 >= 1) 
filter(df_school,visits_by_100751 >= 1 & visits_by_110635 >= 1) # same same
#berkeley or bama
filter(df_school,visits_by_100751 >= 1 | visits_by_110635 >= 1) 
```
Apply \hlgc{count()} function on top of \hlgc{filter()} function to count the number of observations that satisfy criteria

- Avoids printing individual observations
```{r}
count(filter(df_school,visits_by_100751 >= 1 & visits_by_110635 >= 1))
count(filter(df_school,visits_by_100751 >= 1 | visits_by_110635 >= 1))
```

### Filters and comparisons, >=

Number of public high schools that are at least 50% Black in Alabama compared to number of schools that received visit by Bama
```{r}
#at least 50% black
count(filter(df_school, school_type == "public", pct_black >= 50, state_code == "AL"))
count(filter(df_school, school_type == "public", pct_black >= 50, state_code == "AL", visits_by_100751 >= 1))

#at least 50% white
count(filter(df_school, school_type == "public", pct_white >= 50, state_code == "AL"))
count(filter(df_school, school_type == "public", pct_white >= 50, state_code == "AL", visits_by_100751 >= 1))
```
### Filters and comparisons, not equals (\hlgc{!=})

Number of high schools visited by University of Colorado (126614) that are not located in CO
```{r}

#number of high schools visited by U Colorado
count(filter(df_school, visits_by_126614 >= 1))

#number of high schools visited by U Colorado not located in CO
count(filter(df_school, visits_by_126614 >= 1, state_code != "CO"))
#number of high schools visited by U Colorado located in CO
#count(filter(df_school, visits_by_126614 >= 1, state_code == "CO"))
```
### Filters and comparisons, %in% operator

What if you wanted to count the number of schools visited by Bama (100751) in a group of states?
```{r}
count(filter(df_school,visits_by_100751 >= 1, state_code == "MA" | state_code == "VT" | state_code == "ME"))
```
Easier way to do this is with `%in%` operator
```{r}
count(filter(df_school,visits_by_100751 >= 1, state_code %in% c("MA","ME","VT")))
```

Select the private high schools that got either 2 or 3 visits from Bama
```{r}
count(filter(df_school, visits_by_100751 %in% 2:3, school_type == "private"))
```
### Identifying data type and possible values of variable is helpful for filtering

- \hlgc{class()} and \hlgc{str()} shows data type of a variable 
- \hlgc{table()} to show potential values of categorical variables

```{r}
class(df_event$event_type)
str(df_event$event_type)
table(df_event$event_type)

class(df_event$event_state)
str(df_event$event_state) # double quotes indicate character

class(df_event$med_inc)
str(df_event$med_inc)
```

Now that we know `event_type` is a character, we can filter values
```{r}
count(filter(df_event, event_type == "public hs", event_state =="CA"))
#below code would return an error because variables are character
#count(filter(df_event, event_type == public hs, event_state ==CA))
```


### Exercises

Use the data from df_event, which has one observation for each off-campus recruiting event a university attends

1. Count the number of events attended by the University of Pittsburgh (Pitt) \hlgc{univ\_id == 215293}
```{r eval=FALSE, echo=FALSE}
count(filter(df_event, univ_id == 215293))
```
2. Count the number of recruiting events by Pitt at public or private high schools 
```{r eval=FALSE, echo=FALSE}
count(filter(df_event, univ_id == 215293, event_type == "private hs" | event_type == "public hs"))
```
3. Count the number of recruiting events by Pitt at public or private high schools located in the state of PA
```{r eval=FALSE, echo=FALSE}
count(filter(df_event, univ_id == 215293, event_type == "private hs" | event_type == "public hs", event_state == "PA"))
```
4. Count the number of recruiting events by Pitt at public high schools not located in PA where median income is less than 100,000
```{r eval=FALSE, echo=FALSE}
count(filter(df_event, univ_id == 215293, event_type == "public hs", event_state != "PA", med_inc < 100000))
```

5. Count the number of recruiting events by Pitt at public high schools not located in PA where median income is greater than or  equal to 100,000

```{r eval=FALSE, echo=FALSE}
count(filter(df_event, univ_id == 215293, event_type == "public hs", event_state != "PA", med_inc >= 100000))
```
6. Count the number of out-of-state recruiting events by Pitt at private high schools or public high schools with median income of at least 100,000
```{r eval=FALSE, echo=FALSE}
count(filter(df_event, univ_id == 215293, event_state != "PA", (event_type == "public hs" & med_inc >= 100000) | event_type == "private hs"))
```

# Missing values

### Missing values

Missing values have the value \hlgc{NA}

- \hlgc{NA} is a special keyword, not the same as the character string \hlgc{"NA"}
- use \hlgc{is.(na)} function to determine if a value is missing

\medskip
```{r}
is.na(5)
is.na(NA)
is.na("NA")

nvector <- c(10,5,NA)
nvector
is.na(nvector)

svector <- c("e","f",NA,"NA")
svector
is.na(svector)
```

### Missing values are "contageous"

What does "contageous" mean?

- operations involving a missing value will yield a missing value

```{r}
7>5
7>NA
0==NA
2*c(0,1,2,NA)
NA*c(0,1,2,NA)
```
###  Function and missing values, the \hlgc{table()} function

Tip: command \hlgc{str(df\_event)} shows which variables have missing values
```{r results="hide", echo=FALSE}
str(df_event)
```

\hlgc{table()} function useful for investigating categorical variables

- by default \hlgc{table()} ignores \hlgc{NA} values
- the \hlgc{useNA} argument to include \hlgc{NA} values
    - from help file: "useNA controls if the table includes counts of NA values: the allowed values correspond to never ("no"), only if the count is positive ("ifany") and even for zero counts ("always")"
```{r}
table(df_event$g12offered)
nrow(df_event)
table(df_event$g12offered, useNA="always")
```
Broader point:

- Most functions in R ignor missing values by default, but have the option to include missing values
- When investigating data, generally a good idea to always include missing values

### Filtering and missing values

Wickham (2018) states:

- "\hlgc{filter()} only includes rows where condition is TRUE; it excludes both \hlgc{FALSE} and \hlgc{NA} values. To preserve missing values, ask for them explicitly:"

\medskip Investigate var \hlgc{df\_event\textdollar fr\_lunch}, number of free/reduced lunch students

- only available for visits to public high schools

```{r}
#visits to public HS with less than 50 students on free/reduced lunch
count(filter(df_event,event_type == "public hs", fr_lunch<50))
#visits to public HS, where free/reduced lunch missing
count(filter(df_event,event_type == "public hs", is.na(fr_lunch)))
#visits to public HS, where free/reduced is less than 50 OR is missing
count(filter(df_event,event_type == "public hs", fr_lunch<50 | is.na(fr_lunch)))
```


### Exercises, missing values

# Arrange rows

### \hlgc{arrange()} function

\hlgc{arrange()} function "arranges" rows in a data frame; said different, it sorts observations

\medskip
Syntax: \hlgc{arrange(x,\ldots)}

- First argument, \hlgc{x}, is a data frame
- Subsequent arguments are a "comma separated list of unquoted variable names"

```{r, results="hide"}
arrange(df_event, event_date)
```
Data frame goes back to previous order unless you __assign__ the new order
```{r, results="hide"}
df_event
df_event <- arrange(df_event, event_date)
df_event
```
### \hlgc{arrange()} function

Ascending and descending order

- \hlgc{arrange()} sorts in __ascending__ order by default
- use \hlgc{desc()} to sort a column by descending order
```{r results="hide"}
arrange(df_event, desc(event_date))
```

Can sort by multiple variables
```{r results="hide"}
arrange(df_event, univ_id, desc(event_date), desc(med_inc))

#sort by university and descending by size of 12th grade class; combine with select
select(arrange(df_event, univ_id, desc(g12)),instnm,event_type,event_date,g12)
```

### \hlgc{arrange()}, missing values sorted at the end

Missing values automatically sorted at the end, regardless of whether you sort ascending or descending
```{r}
#by university, date, ascending school id
select(arrange(df_event, univ_id, desc(event_date), school_id),instnm,event_date,event_type,school_id)

#by university, date, descending school id
select(arrange(df_event, univ_id, desc(event_date), desc(school_id)),instnm,event_date,event_type,school_id)
```
Can sort by \hlgc{is.na} to put missing values first
```{r}
select(arrange(df_event, univ_id, desc(event_date), desc(is.na(school_id))),instnm,event_date,event_type,school_id)
```

### Exercises, arranging

